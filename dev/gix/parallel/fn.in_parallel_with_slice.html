<!-- Saved from local source at 2025-06-26T01:06:07Z using monolith v2.10.1 -->
<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'unsafe-eval' 'unsafe-inline' data:; style-src 'none'; font-src 'none'; script-src 'none'; img-src data:;"></meta><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An experiment to have fine-grained per-item parallelization with built-in aggregation via thread state. This is only good for operations where near-random access isn’t detrimental, so it’s not usually great for file-io as it won’t make use of sorted inputs well. Note that `periodic` is not guaranteed to be called in case other threads come up first and finish too fast. `consume(&amp;mut item, &amp;mut stat, &amp;Scope, &amp;threads_available, &amp;should_interrupt)` is called for performing the actual computation. Note that `threads_available` should be decremented to start a thread that can steal your own work (as stored in `item`), which allows callees to implement their own work-stealing in case the work is distributed unevenly. Work stealing should only start after having processed at least one item to give all threads naturally operating on the slice some time to start. Starting threads while slice-workers are still starting up would lead to over-allocation of threads, which is why the number of threads left may turn negative. Once threads are started and stopped, be sure to adjust the thread-count accordingly."><title>in_parallel_with_slice in gix::parallel - Rust</title><script></script><link rel="stylesheet"><link rel="stylesheet"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="gix" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js"><script></script><script defer=""></script><script defer=""></script><!--noscript--><!--/noscript--><link rel="alternate icon" type="image/png"><link rel="icon" type="image/svg+xml"><meta name="robots" content="none"></meta></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="file://./gix2/doc/gix/index.html">gix</a><span class="version">0.72.1</span></h2></div><div class="sidebar-elems"><div id="rustdoc-modnav"><h2><a href="file://./gix2/doc/gix/parallel/index.html">In gix::<wbr>parallel</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="file://./gix2/doc/gix/index.html">gix</a>::<wbr><a href="file://./gix2/doc/gix/parallel/index.html">parallel</a></div><h1>Function <span class="fn">in_parallel_with_slice</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub fn in_parallel_with_slice&lt;I, S, R, E&gt;(
    input: &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.slice.html">[I]</a>,
    thread_limit: <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a>&gt;,
    new_thread_state: impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.usize.html">usize</a>) -&gt; S + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    consume: impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;mut I</a>, <a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.reference.html">&amp;mut S</a>, &amp;<a class="struct" href="https://doc.rust-lang.org/1.87.0/core/sync/atomic/struct.AtomicIsize.html" title="struct core::sync::atomic::AtomicIsize">AtomicIsize</a>, &amp;<a class="struct" href="https://doc.rust-lang.org/1.87.0/core/sync/atomic/struct.AtomicBool.html" title="struct core::sync::atomic::AtomicBool">AtomicBool</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.87.0/std/primitive.unit.html">()</a>, E&gt; + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
    periodic: impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.87.0/core/time/struct.Duration.html" title="struct core::time::Duration">Duration</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    state_to_rval: impl <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(S) -&gt; R + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.87.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.87.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;R&gt;, E&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    E: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,
    R: <a class="trait" href="https://doc.rust-lang.org/1.87.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></code></pre><details class="toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An experiment to have fine-grained per-item parallelization with built-in aggregation via thread state.
This is only good for operations where near-random access isn’t detrimental, so it’s not usually great
for file-io as it won’t make use of sorted inputs well.
Note that <code>periodic</code> is not guaranteed to be called in case other threads come up first and finish too fast.
<code>consume(&amp;mut item, &amp;mut stat, &amp;Scope, &amp;threads_available, &amp;should_interrupt)</code> is called for performing the actual computation.
Note that <code>threads_available</code> should be decremented to start a thread that can steal your own work (as stored in <code>item</code>),
which allows callees to implement their own work-stealing in case the work is distributed unevenly.
Work stealing should only start after having processed at least one item to give all threads naturally operating on the slice
some time to start. Starting threads while slice-workers are still starting up would lead to over-allocation of threads,
which is why the number of threads left may turn negative. Once threads are started and stopped, be sure to adjust
the thread-count accordingly.</p>
</div></details></section></div></main></body></html>
