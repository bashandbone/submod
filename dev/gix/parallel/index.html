<!-- Saved from local source at 2025-06-26T01:06:07Z using monolith v2.10.1 -->
<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'unsafe-eval' 'unsafe-inline' data:; style-src 'none'; font-src 'none'; script-src 'none'; img-src data:;"></meta><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Run computations in parallel, or not based the `parallel` feature toggle."><title>gix::parallel - Rust</title><script></script><link rel="stylesheet"><link rel="stylesheet"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="gix" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js"><script></script><script defer=""></script><script defer=""></script><!--noscript--><!--/noscript--><link rel="alternate icon" type="image/png"><link rel="icon" type="image/svg+xml"><meta name="robots" content="none"></meta></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="file://./gix2/doc/gix/index.html">gix</a><span class="version">0.72.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module parallel</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#in_parallel" title="`in_parallel`(…)"><code>in_parallel</code>(…)</a></li><li><a href="#reducestepwise" title="`reduce::Stepwise`"><code>reduce::Stepwise</code></a><ul><li><a href="#maintaining-safety" title="Maintaining Safety">Maintaining Safety</a></li></ul></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="file://./gix2/doc/gix/index.html">In crate gix</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="file://./gix2/doc/gix/index.html">gix</a></div><h1>Module <span>parallel</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><details class="toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Run computations in parallel, or not based the <code>parallel</code> feature toggle.</p>
<h4 id="in_parallel"><a class="doc-anchor" href="#in_parallel">§</a><code>in_parallel</code>(…)</h4>
<p>The <a href="file://./gix2/doc/gix/parallel/fn.in_parallel.html" title="fn gix::parallel::in_parallel"><code>in_parallel(…)</code></a> is the typical fan-out-fan-in mode of parallelism, with thread local storage
made available to a <code>consume(…)</code> function to process input. The result is sent to the <a href="file://./gix2/doc/gix/parallel/trait.Reduce.html" title="trait gix::parallel::Reduce"><code>Reduce</code></a> running in the calling
thread to aggregate the results into a single output, which is returned by <a href="file://./gix2/doc/gix/parallel/fn.in_parallel.html" title="fn gix::parallel::in_parallel"><code>in_parallel()</code></a>.</p>
<p>Interruptions can be achieved by letting the reducers <a href="file://./gix2/doc/gix/parallel/trait.Reduce.html#tymethod.feed" title="method gix::parallel::Reduce::feed"><code>feed(…)</code></a> method fail.</p>
<p>It gets a boost in usability as it allows threads to borrow variables from the stack, most commonly the repository itself
or the data to work on.</p>
<p>This mode of operation doesn’t lend itself perfectly to being wrapped for <code>async</code> as it appears like a single long-running
operation which runs as fast as possible, which is cancellable only by merit of stopping the input or stopping the output
aggregation.</p>
<h4 id="reducestepwise"><a class="doc-anchor" href="#reducestepwise">§</a><code>reduce::Stepwise</code></h4>
<p>The <a href="file://./gix2/doc/gix/parallel/reduce/struct.Stepwise.html" title="struct gix::parallel::reduce::Stepwise"><code>Stepwise</code></a> iterator works exactly as <a href="file://./gix2/doc/gix/parallel/fn.in_parallel.html" title="fn gix::parallel::in_parallel"><code>in_parallel()</code></a> except that the processing of the output produced by
<code>consume(I, &amp;mut State) -&gt; O</code> is made accessible by the <code>Iterator</code> trait’s <code>next()</code> method. As produced work is not
buffered, the owner of the iterator controls the progress made.</p>
<p>Getting the final output of the <a href="file://./gix2/doc/gix/parallel/trait.Reduce.html" title="trait gix::parallel::Reduce"><code>Reduce</code></a> is achieved through the consuming <a href="file://./gix2/doc/gix/parallel/reduce/struct.Stepwise.html#method.finalize" title="method gix::parallel::reduce::Stepwise::finalize"><code>Stepwise::finalize()</code></a> method, which
is functionally equivalent to calling <a href="file://./gix2/doc/gix/parallel/fn.in_parallel.html" title="fn gix::parallel::in_parallel"><code>in_parallel()</code></a>.</p>
<p>In an <code>async</code> context this means that progress is only made each time <code>next()</code> is called on the iterator, while merely dropping
the iterator will wind down the computation without any result.</p>
<h5 id="maintaining-safety"><a class="doc-anchor" href="#maintaining-safety">§</a>Maintaining Safety</h5>
<p>In order to assure that threads don’t outlive the data they borrow because their handles are leaked, we enforce
the <code>'static</code> lifetime for its inputs, making it less intuitive to use. It is, however, possible to produce
suitable input iterators as long as they can hold something on the heap.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="file://./gix2/doc/gix/parallel/reduce/index.html" title="mod gix::parallel::reduce">reduce</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="file://./gix2/doc/gix/parallel/struct.EagerIter.html" title="struct gix::parallel::EagerIter">Eager<wbr>Iter</a></dt><dd>Evaluate any iterator in their own thread.</dd><dt><a class="struct" href="file://./gix2/doc/gix/parallel/struct.InOrderIter.html" title="struct gix::parallel::InOrderIter">InOrder<wbr>Iter</a></dt><dd>An iterator which olds iterated items with a <strong>sequential</strong> ID starting at 0 long enough to dispense them in order.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="file://./gix2/doc/gix/parallel/enum.EagerIterIf.html" title="enum gix::parallel::EagerIterIf">Eager<wbr>Iter<wbr>If</a></dt><dd>An conditional <code>EagerIter</code>, which may become a just-in-time iterator running in the main thread depending on a condition.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="file://./gix2/doc/gix/parallel/trait.Reduce.html" title="trait gix::parallel::Reduce">Reduce</a></dt><dd>An trait for aggregating items commonly produced in threads into a single result, without itself
needing to be thread safe.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.build_thread.html" title="fn gix::parallel::build_thread">build_<wbr>thread</a></dt><dd>Create a builder for threads which allows them to be spawned into a scope and configured prior to spawning.</dd><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.in_parallel.html" title="fn gix::parallel::in_parallel">in_<wbr>parallel</a></dt><dd>Read items from <code>input</code> and <code>consume</code> them in multiple threads,
whose output output is collected by a <code>reducer</code>. Its task is to
aggregate these outputs into the final result returned by this function with the benefit of not having to be thread-safe.</dd><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.in_parallel_if.html" title="fn gix::parallel::in_parallel_if">in_<wbr>parallel_<wbr>if</a></dt><dd>Run <a href="file://./gix2/doc/gix/parallel/fn.in_parallel.html" title="fn gix::parallel::in_parallel"><code>in_parallel()</code></a> only if the given <code>condition()</code> returns true when eagerly evaluated.</dd><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.in_parallel_with_finalize.html" title="fn gix::parallel::in_parallel_with_finalize">in_<wbr>parallel_<wbr>with_<wbr>finalize</a></dt><dd>Read items from <code>input</code> and <code>consume</code> them in multiple threads,
whose output output is collected by a <code>reducer</code>. Its task is to
aggregate these outputs into the final result returned by this function with the benefit of not having to be thread-safe.
Caall <code>finalize</code> to finish the computation, once per thread, if there was no error sending results earlier.</dd><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.in_parallel_with_slice.html" title="fn gix::parallel::in_parallel_with_slice">in_<wbr>parallel_<wbr>with_<wbr>slice</a></dt><dd>An experiment to have fine-grained per-item parallelization with built-in aggregation via thread state.
This is only good for operations where near-random access isn’t detrimental, so it’s not usually great
for file-io as it won’t make use of sorted inputs well.
Note that <code>periodic</code> is not guaranteed to be called in case other threads come up first and finish too fast.
<code>consume(&amp;mut item, &amp;mut stat, &amp;Scope, &amp;threads_available, &amp;should_interrupt)</code> is called for performing the actual computation.
Note that <code>threads_available</code> should be decremented to start a thread that can steal your own work (as stored in <code>item</code>),
which allows callees to implement their own work-stealing in case the work is distributed unevenly.
Work stealing should only start after having processed at least one item to give all threads naturally operating on the slice
some time to start. Starting threads while slice-workers are still starting up would lead to over-allocation of threads,
which is why the number of threads left may turn negative. Once threads are started and stopped, be sure to adjust
the thread-count accordingly.</dd><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.join.html" title="fn gix::parallel::join">join</a></dt><dd>Runs <code>left</code> and <code>right</code> in parallel, returning their output when both are done.</dd><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.num_threads.html" title="fn gix::parallel::num_threads">num_<wbr>threads</a></dt><dd>Returns the amount of threads the system can effectively use as the amount of its logical cores.</dd><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.optimize_chunk_size_and_thread_limit.html" title="fn gix::parallel::optimize_chunk_size_and_thread_limit">optimize_<wbr>chunk_<wbr>size_<wbr>and_<wbr>thread_<wbr>limit</a></dt><dd>Return the ‘optimal’ <em>(<code>size of chunks</code>,  <code>amount of threads as Option</code>, <code>amount of threads</code>)</em> to use in <a href="file://./gix2/doc/gix/parallel/fn.in_parallel.html" title="fn gix::parallel::in_parallel"><code>in_parallel()</code></a> for the given
<code>desired_chunk_size</code>, <code>num_items</code>, <code>thread_limit</code> and <code>available_threads</code>.</dd><dt><a class="fn" href="file://./gix2/doc/gix/parallel/fn.threads.html" title="fn gix::parallel::threads">threads</a></dt><dd>Runs <code>f</code> with a scope to be used for spawning threads that will not outlive the function call.
That way it’s possible to handle threads without needing the ’static lifetime for data they interact with.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="file://./gix2/doc/gix/parallel/type.Scope.html" title="type gix::parallel::Scope">Scope</a></dt><dd>A scope to start threads within.</dd><dt><a class="type" href="file://./gix2/doc/gix/parallel/type.SequenceId.html" title="type gix::parallel::SequenceId">Sequence<wbr>Id</a></dt><dd>A counter for items that are in sequence, to be able to put them back into original order later.</dd></dl></section></div></main></body></html>
